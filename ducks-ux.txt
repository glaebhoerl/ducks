docs: hyperlinked source

ducks.io/syntax (quick reference)
ducks.io/loop
ducks.io/fn (etc)

filesystem hierarchies -> record hierarchies

be much more permissive in devel builds
  type errors are just warnings (-fdefer-type-errors)
  for errors where the solution is unambiguous (missing `;`, tabs vs spaces, ...), compiler just carries on as if it were correct

be much more of a hardass for release builds
  -Werror or something similar (but not for upstream deps, ~Rust)
  optimization _only_ for release builds

"That being said my biggest complaint about Swift is that it lacks Python's simple input() and read() commands. (If you haven't use Python before: input() prompts the user for an input and returns a string, and read() will take the contents from a file and return it as a string.) Having access to simple user/file input dramatically expands the set of examples and assignments I can present in the first month of intro."
-- http://www.aaronblock.com/thoughts/2015/8/21/why-i-want-swift-to-be-your-first-language

Important libraries to steal from other languages
  QuickCheck (smallcheck, ...)
  criterion
Maybe
  diagrams
  opaleye
  reflex / frpnow

"I view programming as making a series of choices; from the macro level which library you're going to pick and how you're going to architect your program to the micro level of how you're going to process this collection into that collection to how you're going to format your code. The difficulty of programming depends on how many of those choices you have to make, and for each choice how easy it is to pick the right alternative.

In Python you have many fewer choices to make, and which alternative is the right one is much more obvious. At the macro level you'll use iterators/generators, no choice to make here. But even at the micro level there are fewer choices. For simple data processing in Python you just use a generator comprehension, always. In Haskell you can use a list comprehension, or use map/filter/etc, or a more sophisticated function. When you've decided to use map/filter, then you still have to decide HOW you're going to do it. Partially applied and composed with .? Or maybe applied to a specific collection? Will you then use nested function calls, or a series of composed functions with . and call it with $ at the end? Across the whole spectrum from which library you're going to pick all the way to minor syntax variations there are just far more choices to make.

There are many things I don't like about Python, but one thing I love is the adherence to its famous principle:

    There should be one -- and preferably only one -- obvious way to do it." -- julesjacobs