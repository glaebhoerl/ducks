docs: hyperlinked source

ducks.io/syntax (quick reference)
ducks.io/loop
ducks.io/fn (etc)

filesystem hierarchies -> record hierarchies

one of the nice things about dynamic languages relative to static ones is that they give you positive feedback sooner (beyond just not having to wait for a compile)
even if in both a static and a dynamic lang, you can get to a working program in 30mins, at the 15mins point...
  dynamic language: my program starts running, does one of the things I want, and then crashes. it almost works!!!
  static language: the compiler was yelling at me about something, I tried to fix it, and now it's yelling at me about something else. will this ever work or am I just a terrible programmer?

be much more permissive in devel builds
  type errors are just warnings (-fdefer-type-errors)
  for errors where the solution is unambiguous (missing `;`, tabs vs spaces, ...?), just carry on as if it were already fixed
    (or even when it's not completely unambiguous, just very probable?)

be much more of a hardass for release builds
  -Werror or something similar (but not for upstream deps, ~Rust)
  optimization can _only_ be enabled for release builds

"That being said my biggest complaint about Swift is that it lacks Python's simple input() and read() commands. (If you haven't use Python before: input() prompts the user for an input and returns a string, and read() will take the contents from a file and return it as a string.) Having access to simple user/file input dramatically expands the set of examples and assignments I can present in the first month of intro."
-- http://www.aaronblock.com/thoughts/2015/8/21/why-i-want-swift-to-be-your-first-language
  say(), listen(), and ask() (= say + listen)?
  (readFile(), writeFile()?)

Important libraries to steal from other languages
  QuickCheck (smallcheck, ...)
  criterion
Maybe
  diagrams
  opaleye
  reflex / frpnow

"I view programming as making a series of choices; from the macro level which library you're going to pick and how you're going to architect your program to the micro level of how you're going to process this collection into that collection to how you're going to format your code. The difficulty of programming depends on how many of those choices you have to make, and for each choice how easy it is to pick the right alternative.

In Python you have many fewer choices to make, and which alternative is the right one is much more obvious. At the macro level you'll use iterators/generators, no choice to make here. But even at the micro level there are fewer choices. For simple data processing in Python you just use a generator comprehension, always. In Haskell you can use a list comprehension, or use map/filter/etc, or a more sophisticated function. When you've decided to use map/filter, then you still have to decide HOW you're going to do it. Partially applied and composed with .? Or maybe applied to a specific collection? Will you then use nested function calls, or a series of composed functions with . and call it with $ at the end? Across the whole spectrum from which library you're going to pick all the way to minor syntax variations there are just far more choices to make.

There are many things I don't like about Python, but one thing I love is the adherence to its famous principle:

    There should be one -- and preferably only one -- obvious way to do it." -- julesjacobs

other devel ergonomics stuff
  `debug(foo)` prints something like file:function:line:column:debug(foo = actual value)

Elm/Haskell style guide https://gist.github.com/evancz/0a1f3717c92fe71702be

Elm error messages: https://twitter.com/henrik/status/649305250713743360
Goal: A radically friendly language

equivalent of Haskell "error" / Rust "panic": oops? sorry?

instead of a `ducksc` program, a single `ducks` which unifies compiler/packager/REPL/docs/..., and then `ducks build` or `ducks make` or smth?

"debugging haskell would be much easier if interpreted haskell had show instances for functions :\" --psygnisfive
  another candidate for "the universal existential type vtable"?
  or rather we already had debug_print in there - difference here is we don't just show the environment, but also the function body?
  maybe this should be accessed through the function pointer in a TNTC kinda way?

"I bet a program that simply overlays a method call with its source & arguments spliced in will vastly improve productivity in any language." --deech

we probably need regexes in some form
  (should we go all the way and add literals, integrate them into pattern matching, ...?)

IDE could have 3 modes:
  textual   editing (like existing IDEs)
  syntactic editing (like Lamdu)
  semantic  editing (like Unison)

doc generation https://internals.rust-lang.org/t/rustdoc-restructuredtext-vs-markdown/356/64
